% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/biqq_es_k.R
\name{biqq_es_k}
\alias{biqq_es_k}
\title{BIQQ Model for k Clues for Origins of Electoral Systems Example}
\usage{
biqq_es_k(k, clue_data, fit = NULL, alpha_prior = rep(1, times = 4),
  pi_alpha = rep(1, times = 4), pi_beta = rep(1, times = 4),
  q0_alpha = rep(1, times = 4), q0_beta = rep(1, times = 4),
  q1_alpha = rep(1, times = 4), q1_beta = rep(1, times = 4),
  extract_pars = "abcd", out_fun = function(x) {     mean(x$abcd[, 2] -
  x$abcd[, 1]) }, iter = 8000, chains = 2, warmup = 1000, cores = 1)
}
\arguments{
\item{k}{Integer. Number of clues sought}

\item{clue_data}{Data frame. All known XYK cases from which only k cases are randomly drawn for BIQQ model}

\item{fit}{Stan model fit object}

\item{alpha_prior}{Numeric vector of length 4. Dirichlet distribution parameters for proportions of 4 possible types in the population. Defaults to \code{c(1,1,1,1)}}

\item{pi_alpha}{Numeric vector of length 4. Alpha shape parameters for Beta distribution of probabilities of assignment for 4 possible types in the population. Defaults to \code{c(1,1,1,1)}}

\item{pi_beta}{Numeric vector of length 4. Beta shape parameters for Beta distribution of probabilities of assignment for 4 possible types in the population. Defaults to \code{c(1,1,1,1)}}

\item{q0_alpha}{Numeric vector of length 4. Alpha shape parameters for Beta distribution of probabilities of not observing clue given that it was sought and any of four possible types. Defaults to \code{c(1,1,1,1)}}

\item{q0_beta}{Numeric vector of length 4. Beta shape parameters for Beta distribution of probabilities of not observing clue given that it was sought and any of four possible types. Defaults to \code{c(1,1,1,1)}}

\item{q1_alpha}{Numeric vector of length 4. Alpha shape parameters for Beta distribution of probabilities of observing clue given that it was sought and any of four possible types. Defaults to \code{c(1,1,1,1)}}

\item{q1_beta}{Numeric vector of length 4. Beta shape parameters for Beta distribution of probabilities of observing clue given that it was sought and any of four possible types. Defaults to \code{c(1,1,1,1)}}

\item{extract_pars}{Character vector. Names of posterior parameters to extract as taken by \code{\link{extract}} function. These should be sufficient to compute output of interest for BIQQ program using \code{out_fun}. Defaults to \code{extract_pars = "abcd"}, which implies a call \code{rstan::extract(posterior, pars = "abcd")}}

\item{out_fun}{Function. The function, which takes posterior samples extracted using \code{extract_pars} as an argument and returns quantity/ies of interest. Defaults to \code{out_fun = function(x) { mean(x$abcd[,2] - x$abcd[,1]) } }, which returns mean of posterior difference between proportions of beneficial and adverse types in the population. This function is used in the replication of Kreuzer study presented in Humphreys, Jacobs (2016)}

\item{iter}{Integer. Total number of iterations in each chain. Defaults to 20000,}

\item{chains}{Integer. Number of MC chains. Defaults to 2}

\item{warmup}{Integer. Number of warm-up iterations in each chain. Defaults to 5000}

\item{cores}{Integer. Number of cores to use for parallel computation. Defaults to 1}
}
\description{
Fit BIQQ Model for Origins of Electoral Systems example assuming that only k clues are sought
}
\examples{

\dontrun{

library(biqq)
es_fit <-
  init_biqq(model_code = stan_es,
            data = data_es_init)

sims <- 10 # Number of simulations
N <- nrow(data_es) # Number of cases

# Generate hyperparameters for Stan
q0_alpha_beta <- mapply(m = c(q.a0 = 0.1, # Assumptions on mean of q0's
                              q.b0 = 0.1,
                              q.c0 = 0.05,
                              q.d0 = 0.3),
                        sd = rep(.01, times = 4),
                        FUN = beta_prior)

q1_alpha_beta <- mapply(m = c(q.a1 = 0.95, # Assumptions on mean of q1's
                              q.b1 = 0.9,
                              q.c1 = 0.475,
                              q.d1 = 0.5),
                        sd = rep(.01, times = 4),
                        FUN = beta_prior)
# Rstan setup options
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

# Run the analysis
betas <-
  parallel::mclapply(X          = rep(0:N, each = sims),
                     FUN        = biqq::biqq_es_k,
                     fit        = es_fit,
                     clue_data  = data_es,
                     q0_alpha   = q0_alpha_beta["alpha",],
                     q0_beta    = q0_alpha_beta["beta",],
                     q1_alpha   = q1_alpha_beta["alpha",],
                     q1_beta    = q1_alpha_beta["beta",],
                     chains     = 2,
                     cores      = 1,
                     extract_pars = "abcd",
                     out_fun = function(x) { mean(x$abcd[,2] - x$abcd[,1]) })

betas <- matrix(unlist(betas), ncol = sims, byrow = TRUE)
}

}
\keyword{biqq}
\keyword{electoral}
\keyword{example}
\keyword{stan}
\keyword{systems}
